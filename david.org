#+TITLE: David's Emacs Configuration

* Configuration
** Initialisation
#+begin_src emacs-lisp


    (defgroup dotemacs nil
      "Custom configuration for dotemacs."
      :group 'local)

    (defcustom dotemacs-cache-directory (concat user-emacs-directory ".cache/")
      "The storage location for various persistent files."
      :group 'dotemacs)

    (add-to-list 'load-path (concat user-emacs-directory "config"))

    (setq custom-file (concat user-emacs-directory "custom.el"))
    (when (file-exists-p custom-file)
      (load custom-file))

    (defcustom dotemacs-modules
      '(init-packages
        init-util
        init-core

        init-bindings
        init-eyecandy

        ;; init-autocomplete
        init-company

        init-yasnippet
        init-org
        init-helm
        init-smartparens
        ;; init-discover
        ;; init-evil
        init-workspace2

        init-macro

        init-c
        init-coffeescript
        init-jade
        init-js
        init-livescript
        init-lua
        init-php
        init-python
        init-web

        init-overrides
        )
      "Set of modules enabled in dotemacs."
      :group 'dotemacs)

    ;; (dolist (module dotemacs-modules)
    ;;   (require module))

  #+end_src
** Packages
#+begin_src emacs-lisp
(setq package-archives '(("melpa" . "http://melpa.milkbox.net/packages/")
                         ("org" . "http://orgmode.org/elpa/")
                         ("marmalade" . "http://marmalade-repo.org/packages/")
                         ("gnu" . "http://elpa.gnu.org/packages/")))
(setq package-enable-at-startup nil)

;; ZOMG C'ETAIS TELLEMENT FUCKING EASY - RIEN NE MARCHE SANS CE TRUC
(package-initialize)

(defun require-package (package)
  "Install given PACKAGE."
  (unless (package-installed-p package)
    (unless (assoc package package-archive-contents)
      (package-refresh-contents))
    (package-install package)))

(provide 'init-packages)
   #+end_src
   
** Util
 #+begin_src emacs-lisp
     (if (fboundp 'with-eval-after-load)
         (defmacro after (feature &rest body)
           "After FEATURE is loaded, evaluate BODY."
           (declare (indent defun))
           `(with-eval-after-load ,feature ,@body))
       (defmacro after (feature &rest body)
         "After FEATURE is loaded, evaluate BODY."
         (declare (indent defun))
         `(eval-after-load ,feature
            '(progn ,@body))))


     (defmacro lazy-major-mode (pattern mode)
       "Defines a new major-mode matched by PATTERN, installs MODE if necessary, and activates it."
       `(add-to-list 'auto-mode-alist
                     '(,pattern . (lambda ()
                                  (require-package (quote ,mode))
                                  (,mode)))))


     (defun my-recompile-init ()
       "Byte-compile all your dotfiles again."
       (interactive)
       (byte-recompile-directory (concat user-emacs-directory "config") 0))


     (defun my-window-killer ()
       "closes the window, and deletes the buffer if it's the last window open."
       (interactive)
       (if (> buffer-display-count 1)
           (if (= (length (window-list)) 1)
               (kill-buffer)
             (delete-window))
         (kill-buffer-and-window)))


     (defun my-minibuffer-keyboard-quit ()
       "Abort recursive edit.
     In Delete Selection mode, if the mark is active, just deactivate it;
     then it takes a second \\[keyboard-quit] to abort the minibuffer."
       (interactive)
       (if (and delete-selection-mode transient-mark-mode mark-active)
           (setq deactivate-mark t)
         (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
         (abort-recursive-edit)))


     (defun set-transparency (alpha)
       "Sets the transparency of the current frame."
       (interactive "nAlpha: ")
       (set-frame-parameter nil 'alpha alpha))


     (defun my-google ()
       "Google the selected region if any, display a query prompt otherwise."
       (interactive)
       (browse-url
        (concat
         "http://www.google.com/search?ie=utf-8&oe=utf-8&q="
         (url-hexify-string (if mark-active
                                (buffer-substring (region-beginning) (region-end))
                              (read-string "Search Google: "))))))


     (defun my-copy-file-name-to-clipboard ()
       "Copy the current buffer file name to the clipboard."
       (interactive)
       (let ((filename (if (equal major-mode 'dired-mode)
                           default-directory
                         (buffer-file-name))))
         (when filename
           (kill-new filename)
           (message "Copied buffer file name '%s' to the clipboard." filename))))


     (defun my-eval-and-replace ()
       "Replace the preceding sexp with its value."
       (interactive)
       (let ((value (eval (preceding-sexp))))
         (backware-kill-sexp)
         (insert (format "%s" value))))


     (defun my-rename-current-buffer-file ()
       "Renames current buffer and file it is visiting."
       (interactive)
       (let ((filename (buffer-file-name)))
         (if (not (and filename (file-exists-p filename)))
             (message "Buffer is not visiting a file!")
           (let ((new-name (read-file-name "New name: " filename)))
             (cond
              ((vc-backend filename) (vc-rename-file filename new-name))
              (t
               (rename-file filename new-name t)
               (set-visited-file-name new-name t t)))))))


     (defun my-delete-current-buffer-file ()
       "Kill the current buffer and deletes the file it is visiting."
       (interactive)
       (let ((filename (buffer-file-name)))
         (when filename
           (if (vc-backend filename)
               (vc-delete-file filename)
             (when (y-or-n-p (format "Are you sure you want to delete %s? " filename))
               (delete-file filename)
               (message "Deleted file %s" filename)
               (kill-buffer))))))


     (defun my-goto-scratch-buffer ()
       "Create a new scratch buffer."
       (interactive)
       (switch-to-buffer (get-buffer-create "*scratch*"))
       (emacs-lisp-mode))


     (defun my-insert-last-kbd-macro ()
       (interactive)
       (name-last-kbd-macro 'my-last-macro)
       (insert-kbd-macro 'my-last-macro))


     (provide 'init-util)

   #+end_src
   
** Core
   #+begin_src emacs-lisp

   #+end_src

** Bindings
   #+begin_src emacs-lisp


   #+end_src

** Eyecandy
   #+begin_src emacs-lisp

   #+end_src

** Company
   #+begin_src emacs-lisp

   #+end_src

** Yasnippet
   #+begin_src emacs-lisp


   #+end_src

** Org
   #+begin_src emacs-lisp

   #+end_src

** Helm
   #+begin_src emacs-lisp

   #+end_src

** Smartparens
   #+begin_src emacs-lisp


   #+end_src

** Discover
   #+begin_src emacs-lisp

   #+end_src

** Evil
   #+begin_src emacs-lisp

   #+end_src

** Workspace
   #+begin_src emacs-lisp


   #+end_src

** Macro
   #+begin_src emacs-lisp

   #+end_src

** Languages modes
*** c
    #+begin_src emacs-lisp

    #+end_src

*** coffeescript
    #+begin_src emacs-lisp


    #+end_src

*** jade
    #+begin_src emacs-lisp

    #+end_src

*** js
    #+begin_src emacs-lisp

    #+end_src

*** livescript
    #+begin_src emacs-lisp

    #+end_src

*** lua
    #+begin_src emacs-lisp

    #+end_src

*** php
    #+begin_src emacs-lisp

    #+end_src

*** python
    #+begin_src emacs-lisp

    #+end_src

*** web
#+begin_src emacs-lisp


#+end_src
** overrides
#+begin_src emacs-lisp


#+end_src
